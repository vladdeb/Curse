unit Algs;

interface

uses
  System.SysUtils, Maps;

function ValidAud(const Aud: String): boolean;
function SearchAud(Uni: TUni; const Aud: String; var Found: integer): TUniPos;
function SearchPath(const Uni: TUni; building: integer; const Graph: TGraph; start, finish: integer): TPath;

implementation

type
  PQueueItem = ^TQueueItem;
  TQueueItem = record
    node: integer;
    dist: integer;
    next: PQueueItem;
  end;

function hash(Uni: TUni; Auditory: TAuditory): integer;
var
  Found: integer;
  AudFull: string;
begin
  AudFull := IntToStr(Auditory.Num);
  if Auditory.isSuf then
    AudFull := AudFull + Auditory.Suf;
  AudFull := AudFull + '-' + IntToStr(Auditory.Building);
  SearchAud(Uni, AudFull, Found);
  result := (Auditory.Num div 100) * 100 + Found;
end;

function encode(aud: string; var code: integer): TAuditory;
begin
  result.isSuf := false;
  result.Suf := ' ';
  result.Building := Ord(Aud[length(Aud)]) - Ord('0');

  val(Copy(Aud, 1, 3), result.Num, code);
  if length(Aud) > 5 then
  begin
    result.isSuf := true;
    result.Suf := Copy(Aud, 4, Length(Aud) - 5);
  end;
end;
//QUEUE FUNCTIONS
procedure Clear(head: PQueueItem);
var
  temp: PQueueItem;
begin
  if head <> nil then
  begin
    temp := head;
    while head <> nil do
    begin
      temp := head;
      head := temp^.next;
      Dispose(temp);
    end;
  end;
end;

procedure Insert(head: PQueueItem; val: integer; node: integer);
var
  temp, newItem: PQueueItem;
begin
  temp := head;
  while (temp^.next <> nil) and (val < temp^.next^.dist) do
    temp := temp^.next;
  New(newItem);
  newItem^.dist := val;
  newItem^.node := node;
  newItem^.next := temp^.next;
  temp^.next := newItem;
end;

function GetFrontNode(head: PQueueItem): integer;
begin
  if head^.next <> nil then
    result := head^.next^.node;
end;

function GetFrontDist(head: PQueueItem): integer;
begin
  if head^.next <> nil then
    result := head^.next^.Dist;
end;

procedure Pop(head: PQueueItem);
var
  temp: PQueueItem;
begin
  if head^.next <> nil then
  begin
    temp := head^.next;
    head^.next := temp^.next;
    Dispose(temp);
  end;
end;


//INPUT CHECK
function ValidAud(const Aud: String): boolean;
var
  n, temp1, temp2: integer;
begin
  result := true;
  n := Length(Aud);
  if n < 5 then
  begin
    result := False;
    Exit;
  end;
  if Aud[n - 1] <> '-' then
  begin
    result := False;
    Exit;
  end;
  if (Aud[n] < '0') or (Aud[n] > '9') then
  begin
    Exit;
  end;

  val(Copy(Aud, 1, 3), temp1, temp2);
  if temp2 <> 0 then
  begin
    result := False;
    Exit;
  end;
end;


//SEARCH OF AUDITORY
function SearchAud(Uni: TUni; const Aud: String; var Found: integer): TUniPos;
var
  Num, code: Integer;
  isSuf: Boolean;
  Suf: String;
  CurFloor: TFloor;
  l, r, m: integer;
  temp, Target: TAuditory;

begin
  Found := -1;
  Target := encode(aud, code);
  result.Building := Target.Building;
  result.Floor := Target.Num div 100;
  if (result.Building > Length(Uni)) or (result.Floor > High(Uni[result.Building - 1])) then
  begin
    Found := -1;
    Exit;
  end;
  CurFloor := Uni[result.Building - 1][result.Floor];
  l := 0;
  r := length(CurFloor);
  //Target := TAuditory.Create(0, 0, Num, Suf, result.Building);
  while (r - l > 1) and (Found = -1) do
  begin
    m := (l + r) div 2;
    temp := CurFloor[m];
    if temp = Target then
    begin
      Found := m;
      result.Pos := temp.Pos;
    end
    else
      if temp < Target then
        l := m + 1
      else
        r := m;
  end;
  if r - l = 1 then
  begin
    if Target = CurFloor[l] then
    begin
      result.Pos := CurFloor[l].Pos;
      Found := l;
      Exit;
    end;
    Found := -1;
  end;
end;

function SearchPath(const Uni: TUni; building: integer; const Graph: TGraph; start, finish: integer): TPath;
var
  Queue: PQueueItem;
  Dist: array[1..1000] of integer;
  prev: array[1..1000] of integer;
  tempLen, tempNode, temp: integer;

const
  inf = 1000000000;

procedure AddToPath(var Path: TPath; Aud: TAuditory);
begin
  setLength(Path, length(Path) + 1);
  Path[length(Path) - 1] := TUniPos.Create(Aud);
end;

begin
  for var i := 1 to 1000 do
  begin
    Dist[i] := inf;
    prev[i] := -1;
  end;
  New(Queue);
  Dist[start] := 0;

  Insert(Queue, 0, start);
  while Queue.next <> nil do
  begin
    tempLen := GetFrontDist(Queue);
    tempNode := GetFrontNode(Queue);
    Pop(Queue);
    if not (tempLen > dist[tempNode]) then
    begin
      for var i := 0 to High(graph[tempNode]) do
      begin
        if dist[hash(Uni, graph[tempNode][i].node)] > dist[tempNode] + graph[tempNode][i].dist then
        begin
          dist[hash(Uni, graph[tempNode][i].node)] := dist[tempNode] + graph[tempNode][i].dist;
          prev[hash(Uni, graph[tempNode][i].node)] := tempNode;
          Insert(Queue, dist[hash(Uni, graph[tempNode][i].node)], hash(Uni, graph[tempNode][i].node));
        end;
      end;

    end;
  end;
  Clear(Queue);
  temp := finish;
  setLength(result, 0);
  while temp <> start do
  begin
    AddToPath(result, Uni[building][temp div 100][temp mod 100]);
    temp := prev[temp];
  end;
  AddToPath(result, Uni[building][start div 100][start mod 100]);
end;
end.
